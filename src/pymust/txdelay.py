from . import utils
import numpy as np

def txdelayCircular(param, tilt, width):
    return txdelay(param, tilt, width)

def txdelayPlane(param, tilt):
    return txdelay(param, tilt)

def txdelayFocused(param, x, y):
    return txdelay(x, y, param)

def txdelay(*args):
    """
    GB Note: uses variable arguments as in matlab, but this is not very pythonic
    %TXDELAY   Transmit delays for a linear or convex array
    %   TXDELAY returns the transmit time delays for focused, plane or circular
    %   beam patterns with a linear or convex array.
    %
    %   DELAYS = TXDELAY(X0,Z0,PARAM) returns the transmit time delays which
    %   must be used to generate a pressure field focused at the point
    %   (x0,z0). Note: If z0 is negative, then the point (x0,z0) is a virtual
    %   source. The properties of the medium and the array must be given in
    %   the structure PARAM (see below).
    %
    %   DELAYS = TXDELAY(PARAM,TILT) returns the transmit time delays which
    %   must be used to get a tilted plane wave. TILT is the tilt angle about
    %   the Y-axis. TILT equals zero radian when a plane wave is not tilted
    %   (the delays are then = 0).
    %
    %   DELAYS = TXDELAY(PARAM,TILT,WIDTH) yields the transmit time delays
    %   necessary for creating a circular wave. The sector enclosed by the
    %   circular waves is characterized by the angular width and tilt. TILT
    %   represents the sector tilt angle about the Y-axis, WIDTH is the sector
    %   width (both in radians). This option is not available for a convex
    %   array.
    %
    %   X0, Z0, TILT and WIDTH can be vectors. In that case, DELAYS is a matrix
    %   whose rows contain the different delay laws.
    %
    %   [DELAYS,PARAM] =  TXDELAY(...) updates the PARAM structure parameters
    %   including the default values. PARAM will also include PARAM.TXdelay
    %   which is equal to DELAYS (in s).
    %
    %   [...] = TXDELAY (no input parameter) runs an interactive example
    %   simulating a focused pressure field generated by a 2.7 MHz phased
    %   array. The user must choose the focus position.
    %
    %   Units: X0,Z0 must be in m; TILT, WIDTH must be in rad. DELAYS are in s.
    %
    %   PARAM is a structure that must contain the following fields:
    %   ------------------------------------------------------------
    %   1) PARAM.pitch: pitch of the linear array (in m, REQUIRED)
    %   2) PARAM.Nelements: number of elements in the transducer array (REQUIRED)
    %   3) PARAM.radius: radius of curvature (in m, default = Inf)
    %   4) PARAM.c: longitudinal velocity (in m/s, default = 1540 m/s)
    %
    %   ---
    %   NOTE #1: X- and Z-axes
    %   The X axis is PARALLEL to the transducer and points from the first
    %   (leftmost) element to the last (rightmost) element (X = 0 at the CENTER
    %   of the transducer). The Z axis is PERPENDICULAR to the transducer and
    %   points downward (Z = 0 at the level of the transducer, Z increases as
    %   depth increases).
    %   ---
    %   NOTE #2: TILT (in radians) describes the tilt angle in the
    %            trigonometric direction. !! NOTE that there was an error in
    %            the version older than 2022-11 !! Sorry about that!
    %   ---
    %
    %   Example #1:
    %   ----------
    %   %-- Generate a focused pressure field with a phased-array transducer
    %   % Phased-array @ 2.7 MHz:
    %   param = getparam('P4-2v');
    %   % Focus position:
    %   x0 = 2e-2; z0 = 5e-2;
    %   % TX time delays:
    %   dels = txdelay(x0,z0,param);
    %   % Grid:
    %   x = linspace(-4e-2,4e-2,200);
    %   z = linspace(0,10e-2,200);
    %   [x,z] = meshgrid(x,z);
    %   % RMS pressure field:
    %   P = pfield(x,z,dels,param);
    %   imagesc(x(1,:)*1e2,z(:,1)*1e2,20*log10(P/max(P(:))))
    %   hold on, plot(x0*1e2,z0*1e2,'k*'), hold off
    %   colormap hot, axis equal tight ij
    %   caxis([-20 0])
    %   c = colorbar;
    %   c.YTickLabel{end} = '0 dB';
    %   xlabel('[cm]')
    %
    %   Example #2:
    %   ----------
    %   %-- Generate a plane wave a convex transducer
    %   % Convex array @ 3.6 MHz:
    %   param = getparam('C5-2v');
    %   % Tilt angle = 10 degrees:
    %   tilt = pi/18; % in rad
    %   % TX apodization
    %   param.TXapodization = [zeros(1,28) ones(1,100) ];
    %   % TX time delays:
    %   dels = txdelay(param,tilt);
    %   % 8cm-by-8cm grid:
    %   [x,z] = impolgrid(100,8e-2,param);
    %   % RMS pressure field:
    %   P = pfield(x,z,dels,param);
    %   pcolor(x*1e2,z*1e2,20*log10(P/max(P(:))))
    %   shading interp
    %   colormap hot, axis equal tight ij
    %   caxis([-20 0])
    %   c = colorbar;
    %   c.YTickLabel{end} = '0 dB';
    %   xlabel('[cm]')
    %
    %
    %   This function is part of <a
    %   href="matlab:web('https://www.biomecardio.com/MUST')">MUST</a> (Matlab UltraSound Toolbox).
    %   MUST (c) 2020 Damien Garcia, LGPL-3.0-or-later
    %
    %   See also PFIELD, SIMUS, DAS, DASMTX, GETPARAM.
    %
    %   -- Damien Garcia -- 2015/03, last update: 2022/10/28
    %   website: <a
    %   href="matlab:web('https://www.biomecardio.com')">www.BiomeCardio.com</a>
    """

    #%-- Check the input arguments
    if len(args) ==2: # % Plane wave: TXDELAY(param,tilt)
        param = args[0]
        option = 'Plane Wave'
    elif len(args) == 3:
        if isinstance(args[2], utils.Param): #% Origo: TXDELAY(x0,z0,param)
            param = args[2]
            option = 'Origo'
        else:#  % Circular wave: TXDELAY(param,tilt,width)
            param = args[0]
            option = 'Circular Wave'
    else:
        ValueError('Wrong input arguments.')

    assert isinstance(param, utils.Param),'Wrong input arguments. PARAM must be a structure.'

    #%-- Number of elements
    if utils.isfield(param,'Nelements'):
        N = param.Nelements
    else:
        raise ValueError('The number of elements (PARAM.Nelements) is required.')

    #%-- Pitch (in m)
    if not utils.isfield(param,'pitch'):
        raise ValueError('A pitch value (PARAM.pitch) is required.')

    #%-- Longitudinal velocity (in m/s)
    if not utils.isfield(param,'c'):
        param.c = 1540

    c = param.c

    #%-- Radius of curvature (in m)
    #% for a convex array
    if not utils.isfield(param,'radius'):
        param.radius = np.inf # % default = linear array

    R = param.radius
    isLINEAR = np.isinf(R)




    #%-- Positions of the transducer elements
    x, z, THe, h= param.getElementPositions()

    if option == 'Plane Wave':
        tilt = np.array(args[1]).reshape((-1, 1)) # Check if it is not a vector
        assert np.all(np.abs(tilt)<np.pi/2), 'The tilt angles must verify |tilt| < pi/2'
        if isLINEAR:
            delays = x*np.sin(tilt)/c
        else:
            #% we have a CONVEX ARRAY
            
            #% intersection point between the wavefront and the transducer
            xn = R*np.sin(tilt)
            zn = R*np.cos(tilt)-h

            #% Note:
            #% Equation of the line tangent to the transducer at (xn,zn):
            #% X = -xn/(zn+h)*(X-xn) + zn
            
            #% distances between this line and the elements (x,z)
            d = np.abs(z+xn/(zn+h)*x-xn**2/(zn+h)-zn)/ \
                np.sqrt(1+xn**2/(zn+h)**2)
            delays = -d/c
    #%-----
    elif option == 'Origo':
        x0 = np.array(args[0]).reshape((-1, 1))
        z0 = np.array(args[1]).reshape((-1, 1))
        assert x0.shape == z0.shape, 'X0 and Z0 must have the same length.'
        delays = np.sqrt((x-x0)**2 + (z-z0)**2)/c
        if isLINEAR:
            delays = -delays*np.sign(z0)
        elif np.sqrt(x0**2 + (R-z0)**2)<R:
            delays = -delays
    #%-----
    elif option == 'Circular Wave':
        assert isLINEAR,'The syntax "TXDELAY(PARAM,TILT,WIDTH)" is not available for a convex array.'
        tilt = np.array(args[1]).reshape((-1, 1))
        width = np.array(args[2]).reshape((-1, 1))
        assert tilt.shape == width.shape, 'TILT and WIDTH must have the same length.'
        assert np.all(np.logical_and(width>0, width<np.pi)), 'The width angles must verify width > 0 and width < pi'
        L = (N-1)*param.pitch
        #%-- Origo
        x0,z0 = angles2origo(L,tilt,width)
        #%--
        delays = np.sqrt((x-x0)**2 + z0**2)/c
        delays = -delays*np.sign(z0)
    delays = delays-np.min(delays,-1).reshape((-1, 1))

    param.TXdelay = delays
    return delays

def angles2origo(L,tilt,width):
    #% Origo (virtual source) from the tilt and width angles
    tilt = np.mod(-tilt+np.pi/2,2*np.pi)-np.pi/2
    SignCorrection = np.ones(tilt.shape)
    idx = np.abs(tilt)>np.pi/2
    tilt[idx] = np.pi-tilt[idx]
    SignCorrection[idx] = -1
    z0 = SignCorrection*L/(np.tan(tilt-width/2)-np.tan(tilt+width/2))
    x0 = SignCorrection*z0*np.tan(width/2-tilt)+L/2
    return x0, z0
