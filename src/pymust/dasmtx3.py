import numpy as np
import scipy, scipy.interpolate
from . import  utils

def dasmtx3(SIG : np.ndarray, x: np.ndarray, y: np.ndarray, z: np.ndarray, *varargin) -> scipy.sparse.spmatrix:
    """
    DASMTX3   Delay-and-sum matrix for 3-D imaging with a matrix array
    M = DASMTX3(SIG,X,Y,Z,DELAYS,PARAM) returns the numel(X)-by-numel(SIG)
    delay-and-sum DAS matrix. The matrix M can be used to beamform SIG (RF
    or I/Q signals) at the points specified by X, Y, and Z.

    Because the signals in SIG are not required (only its size is needed)
    to create M, the following syntax is recommended:
        M = DASMTX3(size(SIG),X,Y,Z,DELAYS,PARAM)
    !IMPORTANT! -- With this syntax, use M = DASMTX3(1i*size(SIG),...) to
    return a complex DAS matrix for I/Q data.

    NOTE: SIG must be a 2-D or 3-D array (the 3rd dimension is ignored).
            Or, size(SIG) must be a two- or three-component vector (the 3rd
            component is ignored). The first dimension (i.e. each column)
            corresponds to a single RF or I/Q signal over (fast-) time, with
            the COLUMN #k corresponding to PARAM.elements #k.

    DASMTX3 returns the same results as DAS3.
        1) using DAS3:
            bfSIG = das3(SIG,x,y,z,delays,param,method);
        2) using DASMTX3:
            M = dasmtx3(size(SIG),x,y,z,delays,param,method);
            bfSIG = M*SIG(:);
            bfSIG = reshape(bfSIG,size(x));

    DELAYS are the transmit time delays (in s). DELAYS must be a vector or
    matrix whose number of elements must be equal to the number of elements
    in the array (which is equal to size(SIG,2)). If a sub-aperture was
    used during transmission, use DELAYS(i) = NaN if element #i of the
    linear array was off.

    PARAM is a structure that contains the parameter values required for
    DAS beamforming (see below for details).

    In 3-D ultrasound imaging with a significant number of elements,
    DASMTX3 can generate tall sparse DAS matrices when beamforming large
    volume data! To avoid memory issues, consider chunking your datasets.

    Let us consider that a series SIG{1}, SIG{2} ... SIG{N} of ultrasound
    matrices have been generated by sending similar wavefronts with the
    same array. To beamform these data with a delay-and-sum
    approach, the following can be used:
        M = dasmtx3(size(SIG),x,y,z,delays,param);
        % (or M = dasmtx3(1i*size(SIG),...) for I/Q data)
        for k = 1:N
            bfSIG{k} = M*reshape(SIG{k},size(SIG{k},1),[]);
            bfSIG{k} = reshape(bfSIG{k},size(x));
        end
    This syntax is much faster than:
        for k = 1:N
            bfSIG{k} = das3(SIG{k},x,y,z,delays,param);
        end

    DASMTX3(SIG,X,Y,Z,PARAM) uses DELAYS = param.TXdelay.

    DASMTX3(...,METHOD) specifies the interpolation method. The available
    methods are decribed in NOTE #3 below.

    [M,PARAM] = DASMTX3(...) also returns the structure PARAM with the
    default values.

    ---
    NOTE #1: X-, Y- and Z-axes
    The migrated signals are calculated at the points specified by (X,Y,Z).
    Conventional axes are used:
    i) For a matrix array, the X-axis is PARALLEL to the transducer. The
        Z-axis is PERPENDICULAR to the transducer and points downward (Z = 0
        at the level of the transducer, Z increases as depth increases). The
        Y-axis corresponds to the elevation direction.
    ---
    NOTE #2: DASMTX3 uses a standard delay-and-sum.
    ---
    NOTE #3: Interpolation methods
    By default DASMTX3 uses a linear interpolation to generate the DAS
    matrix. To specify the interpolation method, use DASMTX3(...,METHOD),
    with METHOD being:
        'nearest'   - nearest neighbor interpolation
        'linear'    - (default) linear interpolation
        'quadratic' - quadratic interpolation
        'lanczos3'  - 3-lobe Lanczos (windowed sinc) interpolation
        '5points'   - 5-point least-squares parabolic interpolation
        'lanczos5'  - 5-lobe Lanczos (windowed sinc) interpolation

    The linear interpolation (it is a 2-point method) returns a matrix
    twice denser than the nearest-neighbor interpolation. It is 3, 4, 5, 6
    times denser for 'quadratic', 'lanczos3', '5points', 'lanczos5',
    respectively (they are 3-to-6-point methods).
    ---

    PARAM is a structure that contains the following fields:
    -------------------------------------------------------
    1)  PARAM.fs: sampling frequency (in Hz, REQUIRED)
    2)  PARAM.elements: coordinates of the transducer elements (in m, REQUIRED)
        PARAM.elements must contain the x- and y-coordinates of the
        transducer elements (the z-coordinates are zero if not given). It
        must be a matrix with 2 (or 3) rows corresponding to the
        x- and y-coordinates (and optionally z), respectively.
    3)  PARAM.fc: center frequency (in Hz, REQUIRED for I/Q signals)
    4)  PARAM.TXdelay: transmission delays (in s, required if DELAYS is not given)
    5)  PARAM.c: longitudinal velocity (in m/s, default = 1540 m/s)
    6)  PARAM.t0: start time for reception (in s, default = 0 s)
    7)  PARAM.fnumber: reception f-number (default = [0 0], i.e. full aperture)
        PARAM.fnumber(1) = reception f-number in the azimuthal x-direction.
        PARAM.fnumber(2) = reception f-number in the elevation y-direction.

    Passive imaging
    ---------------
    8)  PARAM.passive: must be true for passive imaging (i.e. no transmit).
        The default is false.

    This function is part of MUST (Matlab UltraSound Toolbox).
    MUST (c) 2020 Damien Garcia, LGPL-3.0-or-later

    See also DAS(Not available in Python), DASMTX, TXDELAY3, SIMUS3.

    -- Adapted by François Varray & Raphaël Dumas from DASMTX -- 2020/10
    -- Damien Garcia -- last update 2022/12/13
    website: <a
    href="matlab:web('http://www.biomecardio.com')">www.BiomeCardio.com</a>
    """

    #%------------------------%
    #% CHECK THE INPUT SYNTAX %
    #%------------------------%

    NArg = len(varargin) 
    assert NArg>0,'Not enough input arguments.'
    assert NArg<4,'Too many input arguments.'
    # assert(nargout<3,'Too many output arguments.')

    assert x.shape == y.shape == z.shape,'X, Y and Z must of same size.'
    if  np.prod(SIG.shape) in [2, 3]:
        SIG = SIG.flatten()
        nl = int(abs(SIG[0]))
        nc = int(abs(SIG[1]))
    else:
        nl,nc = SIG.shape[0], SIG.shape[1]

    # check if we have I/Q signals
    isIQ = utils.iscomplex(SIG)

    #-- Check input parameters
    if isinstance(varargin[-1], str):
        method = varargin[NArg - 1]
        NArg = NArg-1
    else:
        method = 'linear'
        NArg = NArg

    if NArg==1: # DASMTX3(SIG,x,y,z,param)
        if isinstance(varargin[0], utils.Param):
            param = varargin[0]
            param.ignoreCaseInFieldNames()
        else:
            raise ValueError('The structure PARAM is required.')

        assert utils.isfield(param,'TXdelay'), 'A TX delay vector (PARAM.TXdelay or DELAYS) is required.'
        delaysTX = param.TXdelay

    else: # NArg=6: DASMTX3(SIG,x,y,z,delaysTX,param)
        delaysTX = varargin[0]
        param = varargin[1]
        assert isinstance(param, utils.Param), 'The structure PARAM is required.'
        param.ignoreCaseInFieldNames()

        if utils.isfield(param,'TXdelay'): # DASMTX3(SIG,x,y,z,delaysTX,param)
            assert np.allclose(delaysTX.flatten(), param.TXdelay.flatten()),'If both specified, PARAM.TXdelay and DELAYS must be equal.'


    #-- Interpolation method
    if method.lower() not in ['nearest','linear','quadratic','lanczos3','5points','lanczos5']:
        raise ValueError('METHOD must be "nearest", "linear", "quadratic", "Lanczos3", "5points" or "Lanczos5".')


    #-- Propagation velocity (in m/s)
    if not utils. isfield(param,'c'):
        param.c = 1540 # longitudinal velocity in m/s


    #-- Sampling frequency (in Hz)
    if param.get('fs', None) is None:
        raise ValueError('A sampling frequency (PARAM.fs) is required.')

    #-- f-number
    if not utils.isfield(param,'fnumber'):
        param.fnumber = np.array([0, 0]) # f-number (default = full aperture)
    elif not isinstance(param.fnumber,np.ndarray) and param.fnumber == 0:
        param.fnumber = np.array([0, 0])
    elif param.get('fnumber', 'None') is not None:
        param.fnumber = np.array(param.fnumber) # DR : convert to numpy array
        assert param.fnumber.shape == (2,), 'PARAM.fnumber must contain two elements.'
        assert utils.isnumeric(param.fnumber), 'PARAM.fnumber must be a scalar.'
        assert (param.fnumber>=0).all(), 'PARAM.fnumber must be non-negative.'

    #-- Acquisition start time (in s)
    if not utils.isfield(param,'t0'):
        param.t0 = np.zeros((1,1)) # acquisition start time in s
    
    #-- Element width (in m)
    if not utils.isfield(param,'width'):
        raise ValueError('An element width (PARAM.width) is required.')
    ElementWidth = param.width # DR : Can element width be measured out from elements array?
    
    #-- Element height (in m)
    if not utils.isfield(param,'height'):
        raise ValueError('An element height (PARAM.height) is required.')
    ElementHeight = param.height # DR : Can element height be measured out from elements array?
        
    #-- Radius of curvature (in m)
    # for a convex array
    if not utils.isfield(param,'radius'):
        param.radius = np.inf # default = linear array
    else:
        assert np.isinf(param.radius), 'DASMTX3 does not address matrix convex arrays.'

    #-- Reception angle (in rad) -- [option not available in DASMTX3] --
    if not utils.isfield(param,'RXangle'):
        param.RXangle = 0
    else:
        assert param.RXangle == 0, 'PARAM.RXangle must be 0 with DASMTX3.'

    #-- Passive imaging
    if not utils.isfield(param,'passive'):
        param.passive = False
    else:
        assert utils.islogical(param.passive), 'PARAM.passive must be a boolean (false or true)'

    # NoteGB: Temporary, while checking the code of virtual sources in the DAS matrix
    if not utils.isfield(param,'useVirtualSource'):
        useVirtualSource = False
    else:
        useVirtualSource = param.useVirtualSource



    #-- Coordinates of the transducer elements (xe,ye,ze)
    assert utils.isfield(param,'elements'), 'PARAM.elements must contain the x- and y-locations of the transducer elements.'
    if param.elements.shape[1] in [2,3]: # param.elements is a two(or 3)-column matrix, convert it to a row matrix
        param.elements = param.elements.T
    assert param.elements.shape[0] in [2, 3], 'PARAM.elements must be a 2 (or 3)-row matrix that contains the x, y (and optionally z)-coordinates of the transducer elements.'
    
    xe = param.elements[0, :]
    ye = param.elements[1, :]
    if param.elements.shape[0] == 3:
        ze = param.elements[2, :]
    else:
        ze = np.zeros_like(xe)

    #-- Number of elements
    if delaysTX.shape[0] == nc and delaysTX.shape[1] != nc:
        delaysTX = delaysTX.T

    assert delaysTX.shape[1]==nc, 'DELAYS and/or PARAM.TXdelay must be vectors of length size(SIG,2).'
    # Note: param.Nelements can be required in other functions of the
    #       Matlab Ultrasound Toolbox
    if utils.isfield(param,'Nelements'):
        assert param.Nelements==nc, 'PARAM.TXdelay or DELAYS must be of length PARAM.Nelements.'
    assert xe.size == nc, 'The number of elements must be equal to size(SIG,2).'

    #-- Center frequency (in Hz)
    if isIQ:
        if utils.isfield(param,'fc'):
            if utils.isfield(param,'f0'):
                assert abs(param.fc-param.f0)<utils.eps(), \
                    'A conflict exists for the center frequency: PARAM.fc and PARAM.f0 are different!'

        elif utils.isfield(param,'f0'):
            param.fc = param.f0 # Note: param.f0 can also be used
        else:
            raise ValueError('A center frequency (PARAM.fc) is required with I/Q data.')
        
        wc = 2*np.pi*param.fc


    #%-------------------------------%
    #% end of CHECK THE INPUT SYNTAX %
    #%-------------------------------%



    # some parameters
    fs = param.fs # sampling frequency
    c = param.c   # propagation velocity


    # Interpolations of the TX delays for a better estimation of dTX
    # idx = np.logical_not(np.isnan(delaysTX))
    # assert np.sum(np.abs(np.diff(idx)))<3, 'Several simultaneous sub-apertures are not allowed.'

    # if not param.passive:
    #     nTX = np.count_nonzero(idx)#; % number of transmitting elements
    #     if nTX>1:
    #         idxi = np.linspace(0,nTX -1,4*nTX)
    #         xTi = utils.interp1(xe[idx], idxi, kind = 'cubic')
    #         zTi = np.zeros_like(xTi)
    #         delaysTXi = utils.interp1(delaysTX[idx],idxi,'spline')
    #     else:
    #         xTi = xe[idx]
    #         zTi =np.zeros_like(idx)
    #         delaysTXi = delaysTX[idx]

    # DR : The current MUST (and PyMUST) implementation doesn't calculate the f-number (f-number is converted to [0,0] if None)
    #-- f-number (determined automatically if not given)
    # The f-number is determined from the element directivity
    # See the paper "So you think you can DAS?"
    if param.get('fnumber', None) is None:
        param.fnumber = np.array([0, 0]) # Initialize f-number
        lambdaMIN = c/(param.fc*(1+param.bandwidth/200))
        RXa = abs(param.RXangle)
        # Note: in Matlab, sinc(x) = sin(pi*x)/(pi*x)
        f = lambda th,width= ElementWidth,l= lambdaMIN: np.abs(np.cos(th+RXa)*np.sinc(width/l*np.sin(th+RXa))-0.71)
        xx = scipy.optimize.fminbound(f,0,np.pi/2-RXa,xtol= np.pi/100)
        alpha = xx
        param.fnumber[0] = 1/2/np.tan(alpha)
        xx = scipy.optimize.fminbound(f,0,np.pi/2-RXa,xtol= np.pi/100,args=(ElementHeight,)) # Calculate 2nd f-number based on ElementHeight
        alpha = xx
        param.fnumber[1] = 1/2/np.tan(alpha)

    fNum = param.fnumber


    t0 = param.t0
    x = x.reshape((-1,1), order = 'F')
    y = y.reshape((-1,1), order = 'F')
    z = z.reshape((-1,1), order = 'F')
    Nx = x.size

    #%------------------------------------------------------%
    #% Migration - diffraction summation (Delay & Sum, DAS) %
    #%------------------------------------------------------%

    xe = xe.reshape((1,-1), order = 'F')
    ye = ye.reshape((1,-1), order = 'F')
    ze = ze.reshape((1,-1), order = 'F')
    
    #-- TX and RX distances
    dxT = x-xe; dyT = y-ye; dzT = z-ze
    dRX = np.sqrt(dxT**2 + dyT**2 + dzT**2)
    
    if  param.passive:
        dTX = np.zeros_like(x)
    elif not useVirtualSource:
        dTX = np.min(delaysTX*c + dRX, axis = 1).reshape((-1,1), order = 'F')
    else:
        #%-- First check which elements were transmitting
        WasTransmitting = np.logical_not(np.isnan(delaysTX))
        nTX = np.count_nonzero(WasTransmitting); # number of transmitting elements

        #%-- TX distances
        if nTX==1:
            #% Only one element was active
            dTX = np.hypot(xe[WasTransmitting]-x,ze[WasTransmitting]-z) + \
                delaysTX[WasTransmitting]*c;

        elif nTX<3:
            raise ValueError('If not 1, the number of transmitting elements must be at least 3.')

        else:
            #%-- We create a virtual transducer to calculate the TX distances.
            xv,yv,zv = vxdcr3(xe[WasTransmitting],ye[WasTransmitting], \
                delaysTX[WasTransmitting],c);

            [DzvDx,DzvDy] = trigrad(xv,yv,zv);

            # Distances between the (x,y,z) points and the lines normal to the
            # virtual transducer at (xv,yv,zv)
            Dn = np.abs(DzvDx*(y-yv) + DzvDy*(z-zv) - (x-xv))/np.abs(1+DzvDx**2+DzvDy**2);
            #idx contains the element numbers that give the smallest Dn_s
            idx = np.argmin(Dn, 1)

            dTX = np.sqrt((xv[idx].reshape((-1,1))-x)**2 + (yv[idx].reshape((-1,1))-y)**2 + (zv[idx].reshape((-1,1))-z)**2);

    x,y,z = None, None, None # clear x y z
 
    #-- Travel times
    tau = (dTX+dRX)/c
    dTX, dRX = None, None # clear dTX and dRX
    
    #-- Corresponding fast-time indices
    idxt = (tau-t0.reshape((1, -1)))*fs
    idxt = idxt.astype(np.float64) # in case tau is in single precision

    #-- In-range indices:
    method = method.lower()  
    if method == 'nearest':
        I = np.logical_and(idxt>=0, idxt<=nl - 1)
    elif method == 'linear':
        I = np.logical_and(idxt>=0, idxt<=nl -2 )
    elif method == 'quadratic':
        I = np.logical_and(idxt>=0, idxt<=nl -3 )
    elif method == 'lanczos3':
        I = np.logical_and(idxt>=0, idxt<=nl -3 )
    elif method == '5points':
        I = np.logical_and(idxt>=0, idxt<=nl -3 )
    elif method == 'lanczos5':
        I = np.logical_and(idxt>=0, idxt<=nl -4 )
    else:
        raise ValueError('Unknown interpolation method: %s' % method)

    #-- Aperture (using the f-number):
    if (fNum != 0).any():
        #-- for a planar array
        Iaperture = np.logical_and(np.abs(dxT)<=(np.abs(dzT)*fNum[0]),np.abs(dyT)<=(np.abs(dzT)*fNum[1]))
        I = np.logical_and(I,Iaperture)
    
    dxT, dyT, dzT = None, None, None # clear dxT dyT dzT

    # subscripts to linear indices (instead of using SUB2IND)
    idx_matrix = idxt + np.arange(nc).reshape((1, -1))*nl
    idxt = None # clear idxt
    j, i = np.where(I.T) # GB: This weird inverion is to make sure that the ordering is consistent with matlab
    idx = np.take(idx_matrix, np.ravel_multi_index([i,j], I.shape))
    tau_I = np.take(tau, np.ravel_multi_index([i,j], I.shape))

    if method != 'nearest':
        idxf = np.floor(idx).astype(int)
        idx = idx-idxf

    #-- Let's fill in the sparse DAS matrix
    if method == 'nearest': #-- Nearest neighbor interpolation (1-point method)
        j = np.round(idx).astype(int)
        s = np.ones_like(i)
        n_repeat = 1
            
    elif method == 'linear': #-- Linear interpolation (2-point method)
        #-- DAS matrix
        j = np.concatenate([idxf, idxf+1])
        s = np.concatenate([-idx+1,  idx])
        n_repeat = 2
    elif method == 'quadratic': #-- quadratic interpolation (3-point method)

        #-- DAS matrix
        j = np.concatenate([idxf, idxf+1, idxf+2])
        s = np.concatenate([(idx-1)*(idx-2)/2,
            -idx*(idx-2),
            idx*(idx-1)/2])      
        n_repeat = 3
    elif method ==  'lanczos3': #-- 3-lobe Lanczos interpolation (4-point method)
        j = np.concatenate([idxf-1, idxf, idxf+1, idxf+2])
        s = np.concatenate([np.sinc(idx+1)*np.sinc((idx+1)/2),
            np.sinc(idx)*np.sinc(idx/2),
            np.sinc(idx-1)*np.sinc((idx-1)/2),
            np.sinc(idx-2)*
            np.sinc((idx-2)/2)])
        n_repeat = 4
    elif method == '5points': #-- 5-point least-squares parabolic interpolation (5-point method)
        j =  np.concatenate([idxf-2, idxf-1, idxf, idxf+1, idxf+2])
        idx2 = idx**2
        s *= np.concatenate([1/7*idx2-1/5*idx-3/35,
            -1/14*idx2-1/10*idx+12/35,
            -1/7*idx2+17/35,
            -1/14*idx2+1/10*idx+12/35,
            1/7*idx2+1/5*idx-3/35])
        n_repeat = 5
    elif method == 'lanczos5': #-- 5-lobe Lanczos interpolation (6-point method)
        j = np.concatenate([idxf-2, idxf-1, idxf, idxf+1, idxf+2, idxf+3])
        s = np.concatenate([np.sinc(idx+2)*np.sinc((idx+2)/2),
            np.sinc(idx+1)*np.sinc((idx+1)/2),
            np.sinc(idx)*np.sinc(idx/2),
            np.sinc(idx-1)*np.sinc((idx-1)/2),
            np.sinc(idx-2)*np.sinc((idx-2)/2),
            np.sinc(idx-3)*np.sinc((idx-3)/2)])
        n_repeat = 6
        
    idx = None # clear idx

    i = np.tile(i, n_repeat)
    if isIQ:
        s = np.exp(1j*wc*np.tile(tau_I, n_repeat)) * s
        
    tau = None # clear tau

    if utils.isfield(param,'TransposeDASMatrix'):
        # -- DASMTX has been called by the function DAS --
        #
        # The smallest DAS matrix (in terms of memory) is returned.
        # (Matlab stores sparse matrices in compressed sparse column format)
        if Nx>nl*nc:
            param.TransposeDASMatrix = False
            M = scipy.sparse.coo_matrix((s,(i,j)), shape = (Nx,nl*nc))
            # M is a [numel(x)]-by-[nl*nc] sparse matrix
        else:
            param.TransposeDASMatrix = True
            M = scipy.sparse.coo_matrix((s,(j,i)),shape = (nl*nc, Nx))
            # M is a [nl*nc]-by-[numel(x)] sparse matrix
    else:
        M = scipy.sparse.coo_matrix((s,(i,j)), shape= (Nx,nl*nc))
            # M is a [numel(x)]-by-[nl*nc] sparse matrix
    return M #TODO: maybe use another type of sparse matrix will be more efficient


class DasMTX3:
    def __init__(self, SIG, x, y, z, *varargin):
        self.M = dasmtx3(SIG, x, y, z, *varargin)
        self.shape = x.shape
    def __apply__(self, SIG, axis):
        return (self.M @ SIG.flatten(order = 'F')).reshape(self.shape, order = 'F')
    

def  vxdcr3(xe,ye,delaysTX,c):
    """
    %VXDCR3   3-D virtual transducer (XDCR)
    %   [xV,zV,zV] = VXDCR3 returns the positions of the elements of the 3-D
    %   virtual transducer.
    %
    %   The virtual transducer is an "equivalent" transducer assuming null
    %   delays.
    %
    %   -- Damien Garcia -- 2024/06, last update: 2024/06/26
    %                                [simplified version]
    """"
    T2 = delaysTX.flatten(order = "F")**2
    xe = xe.flatten(order = 'F')
    ye = ye.flatten(order = 'F')
    dT2dx,dT2dy = trigrad(xe,ye,T2);
    xV = xe-c**22*dT2dx/2;
    yV = ye-c**2*dT2dy/2;
    zV = -np.sqrt(np.abs(c**2*T2-(xe-xV)**2-(ye-yV)**2));
    return xV,yV,zV

def trigrad(x : np.ndarray, y : np.ndarray, z : np.ndarray):
    """
    Compute an approximation to the gradient of Z defined for scattered data (X, Y).

    Parameters:
    x, y, z : array-like
        Coordinates and corresponding function values. All must have the same shape.

    Returns:
    dzdx, dzdy : ndarray
        Approximations to the partial derivatives dZ/dX and dZ/dY.
    """
    siz0 = x.shape

    x = np.asarray(x).flatten(order = 'F')
    y = np.asarray(y).flatten(order = 'F')
    z = np.asarray(z).flatten(order = 'F')

    assert x.shape == y.shape == z.shape, "X, Y, and Z must have the same size"


    # Delaunay triangulation
    tri = scipy.spatial.Delaunay(np.vstack((x, y)).T , qhull_options = 'Qt Qbb Qc') # To make it consistent with Matlab (https://stackoverflow.com/questions/36604172/difference-between-matlab-delaunayn-and-scipy-delaunay)
    dt = tri.simplices

    # Number of triangles and points
    nt = dt.shape[0]
    np_points = len(z)

    # Coefficients for the planes (triangles)
    # [x1 y1 1; x2 y2 1; x3 y3 1][a; b; c] = [z1; z2; z3]

    vals = np.vstack([np.take(x, dt).flatten(), np.take(y, dt).flatten(), np.ones(3*nt) ]).T
    rows =  np.repeat(np.arange(3*nt).reshape((-1, 1), order = 'F'), 3, axis = 1)
    cols = np.kron(np.arange(3*nt).reshape(3, nt, order = 'F') , np.ones((1,3), dtype = int)).T
    Cm =scipy.sparse.coo_matrix((vals.flatten(order = 'F'), (rows.flatten(order = 'F'), cols.flatten(order = 'F')))).tocsr()
    C = scipy.sparse.linalg.spsolve(Cm, np.take(z, dt).flatten() ).reshape((-1, 3))

    # Side lengths of the triangles
    s1 = np.hypot(x[dt[:, 1]] - x[dt[:, 0]], y[dt[:, 1]] - y[dt[:, 0]])
    s2 = np.hypot(x[dt[:, 2]] - x[dt[:, 0]], y[dt[:, 2]] - y[dt[:, 0]])
    s3 = np.hypot(x[dt[:, 2]] - x[dt[:, 1]], y[dt[:, 2]] - y[dt[:, 1]])

    # Semi-perimeters
    s = (s1 + s2 + s3) / 2

    # Areas (Heron's formula)
    A = np.sqrt(s * (s - s1) * (s - s2) * (s - s3))

    # "Equilaterality" of the triangles (= 2*inradius/circumradius):
    # 1 if equilateral, 0 if degenerate
    E = 8 * A**2 / (s * s1 * s2 * s3)

    # Map matrix from triangles to nodes
    row_idx = np.repeat(np.arange(nt), 3)
    col_idx = dt.flatten()
    data = np.ones(len(row_idx))

    M = scipy.sparse.coo_matrix((data, (row_idx, col_idx)), shape=(nt, np_points))

    # Weighted mean of the partial derivatives (a or b coefficient) using the
    # "equilaterality" of each triangle for a given node
    dzdx = M.T @ (C[:, 0] * E) / (M.T @ E)
    dzdy = M.T @ (C[:, 1] * E) / (M.T @ E)

    dzdx = dzdx.reshape(siz0, order = 'F')
    dzdy = dzdy.reshape(siz0, order = 'F')

    return dzdx, dzdy