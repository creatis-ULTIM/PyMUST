import numpy as np
from . import utils

# Ugly optimisation trick, of loop unraveling, as np.mean/np.sum has a large overhead for iterating over few dimesions
# for i in range(1, 10):
#   r = '+'.join([f'X[...,{j}]' for j in range(i)])
#   print(f'average_function_by_i[{i}] = lambda X: ({r})/{i}')
average_function_by_i = [None] * 10
average_function_by_i[1] = lambda X: (X[...,0])/1
average_function_by_i[2] = lambda X: (X[...,0]+X[...,1])/2
average_function_by_i[3] = lambda X: (X[...,0]+X[...,1]+X[...,2])/3
average_function_by_i[4] = lambda X: (X[...,0]+X[...,1]+X[...,2]+X[...,3])/4
average_function_by_i[5] = lambda X: (X[...,0]+X[...,1]+X[...,2]+X[...,3]+X[...,4])/5
average_function_by_i[6] = lambda X: (X[...,0]+X[...,1]+X[...,2]+X[...,3]+X[...,4]+X[...,5])/6
average_function_by_i[7] = lambda X: (X[...,0]+X[...,1]+X[...,2]+X[...,3]+X[...,4]+X[...,5]+X[...,6])/7
average_function_by_i[8] = lambda X: (X[...,0]+X[...,1]+X[...,2]+X[...,3]+X[...,4]+X[...,5]+X[...,6]+X[...,7])/8
average_function_by_i[9] = lambda X: (X[...,0]+X[...,1]+X[...,2]+X[...,3]+X[...,4]+X[...,5]+X[...,6]+X[...,7]+X[...,8])/9

def average_over_last_axis(X):
    if X.shape[-1] < len(average_function_by_i):
        return average_function_by_i[X.shape[-1] ](X)
    else:
        return np.mean(X, axis = -1)

eps = np.finfo(np.float32).eps
mysinc = lambda x = None: np.sin(np.abs(x) + eps)/ (np.abs(x) + eps) # [note: In MATLAB/numpy, sinc is sin(pi*x)/(pi*x)]
 
def pfield3(x : np.ndarray, y : np.ndarray, z: np.ndarray, delaysTX : np.ndarray, param: utils.Param, isQuick : bool = False, options : utils.Options = None):
    """
    PFIELD3   3-D RMS acoustic pressure field of a planar 2-D array
    RP = PFIELD3(X,Y,Z,DELAYS,PARAM) returns the three-dimensional
    radiation pattern of a planar 2-D array whose elements are excited at
    different time delays (given by the vector DELAYS). The radiation
    pattern RP is given in terms of the root-mean-square (RMS) of acoustic
    pressure. The characteristics of the array and transmission must be
    given in the structure PARAM. The x- and y-coordinates of the elements
    must be in PARAM.elements (see below for details). The radiation
    pattern is calculated at the points specified by (X,Y,Z).

    Use PFIELD for uniform linear or convex arrays.

    >--- Try it: enter "pfield3" in the command window for an example ---<

    Units: X,Y,Z must be in m; DELAYS must be in s.

    DELAYS can be a matrix. This syntax can be used to simulate MPT
    (multi-plane transmit) sequences, for example. In this case, each ROW
    represents a delay series. For example, to create a 3-MPT sequence with
    a 1024-element matrix array, the DELAYS matrix must have 3 rows and
    1024 columns (size = [3 1024]).

    Note: Use TXDELAY3 to create standard delays (focus point, focus line,
            plane waves, diverging waves) with a matrix array.

    PFIELD3 is called by SIMUS3 to simulate ultrasound RF radio-frequency
    signals generated by a planar 2-D array.

    ---
    NOTE #1: X-, Y-, and Z-axes
    Conventional axes are used:
    The X-axis is PARALLEL to the transducer and points from the first
    (leftmost) element to the last (rightmost) element (X = 0 at the CENTER
    of the transducer). The Z-axis is PERPENDICULAR to the transducer and
    points downward (Z = 0 at the level of the transducer, Z increases as
    depth increases). The Y-axis is such that the coordinates are
    right-handed.
    ---
    NOTE #2: Simplified method: Directivity
    By default, the calculation is made faster by assuming that the
    directivity of the elements is dependent only on the central frequency.
    This simplification very little affects the pressure field in most
    situations (except near the array). To turn off this option, use
    OPTIONS.FullFrequencyDirectivity = true.
    (see ADVANCED OPTIONS below).
    ---
    NOTE #3: Present version of PFIELD3
    The present version of PFIELD3 only considers planar 2-D array whose
    z-coordinates of the elements are 0. All the elements are rectangular
    and have equal width and height.
    ---


    PARAM is a structure that contains the following fields:
    -------------------------------------------------------
        *** TRANSDUCER PROPERTIES ***
    1)  PARAM.fc: central frequency (in Hz, REQUIRED)
    2)  PARAM.elements: x- and y-coordinates of the element centers
            (in m, REQUIRED). It MUST be a two-row matrix, with the 1st
            and 2nd rows containing the x and y coordinates, respectively. 
    3)  PARAM.width: element width, in the x-direction (in m, REQUIRED)
    4)  PARAM.height: element height, in the y-direction (in m, REQUIRED)
    5)  PARAM.bandwidth: pulse-echo 6dB fractional bandwidth (in #)
            The default is 75#.
    6)  PARAM.baffle: property of the baffle:
            'soft' (default), 'rigid', or a scalar > 0.
            See "Note on BAFFLE properties" below for details

        *** MEDIUM PARAMETERS ***
    7)  PARAM.c: longitudinal velocity (in m/s, default = 1540 m/s)
    8)  PARAM.attenuation: attenuation coefficient (dB/cm/MHz, default: 0)
            Notes: A linear frequency-dependence is assumed.
                    A typical value for soft tissues is ~0.5 dB/cm/MHz.

        *** TRANSMIT PARAMETERS ***
    9)  PARAM.TXapodization: transmit apodization (default: no apodization)
    10) PARAM.TXnow: number of wavelengths of the TX pulse (default: 1)
    11) PARAM.TXfreqsweep: frequency sweep for a linear chirp (default: [])
                            To be used to simulate a linear TX down-chirp.


    Note on CHIRP signals:
    ---------------------
    Linear chirps are characterized by PARAM.TXnow, PARAM.fc and
    PARAM.TXfreqsweep. The transmitted pulse has a duration of
    approximately T (= PARAM.TXnow/PARAM.fc), with the amplitude and phase
    defined over the time interval -T/2 to +T/2. The total frequency sweep
    is DeltaF (= PARAM.TXfreqsweep): the frequencies changes linearly from
    (PARAM.fc + DeltaF/2) to (PARAM.fc - DeltaF/2) in the defined time
    interval.


    Note on BAFFLE property:
    -----------------------
    In PFIELD3, it is assumed by default that the array elements are
    embedded in an infinite SOFT baffle. To modify the property of the
    baffle, modify the field PARAM.baffle:
        1) 'rigid'
        2) 'soft' (this is the default)
        3) a nonnegative scalar Alpha,
            with Alpha = (medium impedance)/(baffle impedance)
            Note: Alpha = 0 => 'rigid'; Alpha >> 1 => 'soft'

    The baffle property affects the obliquity factor included in the
    directivity of the elements. This obliquity factor is not 1 if the
    baffle is not rigid. A general case (see case #3 below) can be chosen
    by specifying an impedance ratio. For details, refer to the
    corresponding papers.
    1) For a rigid baffle => obliquity factor = 1.
    2) For a soft baffle => obliquity factor = cos(Theta).
        Selfridge et al. Appl Phys Lett 37(1), 35-36 (1980)
        "A theory for the radiation pattern of a narrow-strip acoustic
        transducer." <a
        href="matlab:web('http://scitation.aip.org/content/aip/journal/apl/37/1/10.1063/1.91692')">Paper here</a>
    3) General baffle => obliquity factor = cos(Theta)/(cos(Theta)+Alpha)
        with Alpha = (medium impedance)/(baffle impedance).
        Pesquï¿½ et al. IEEE Ultrasonics Symposium, (1984)
        "Effect of the planar baffle impedance in acoustic radiation of a
        phased array element theory and experimentation." <a
        href="matlab:web('http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1535402')">Paper here</a>
        Example: For a baffle of impedance 2.8 MRayl (epoxy) adjacent to
                soft tissues of impedance 1.6 MRayls, alpha = 0.57.


    ADVANCED OPTIONS:
    ----------------
        %-- FREQUENCY SAMPLES --%
    1)  Only frequency components of the transmitted signal in the range
        [0,2fc] with significant amplitude are considered. The default
        relative amplitude is -60 dB in PFIELD. You can change this value
        by using the following:
            [...] = PFIELD(...,OPTIONS),
        where OPTIONS.dBThresh is the threshold in dB (default = -60).
    ---
        %-- FULL-FREQUENCY DIRECTIVITY --%
    2)  By default, the directivity of the elements depends on the center
        frequency only. This makes the algorithm faster. To make the
        directivities fully frequency-dependent, use:
            [...] = PFIELD(...,OPTIONS),
        with OPTIONS.FullFrequencyDirectivity = true (default = false).
    ---
        %-- ELEMENT SPLITTING --%
    3)  Each transducer element of the array is split into small rectangles.
        The width and height and of these small rectangles must be small
        enough to ensure that the far-field model is accurate. By default,
        the elements are split into M-by-N rectangles, with M and N being
        defined by:
            M = ceil(element_width/smallest_wavelength);
            N = ceil(element_height/smallest_wavelength);
        To modify the number MN of subelements by splitting, you may adjust
        OPTIONS.ElementSplitting, which must contain two elements. For
        example, OPTIONS.ElementSplitting = [1 3].
    ---



    Notes regarding the model & REFERENCES:
    --------------------------------------
    1) PFIELD3 works for planar 2-D arrays. It considers arrays that have
        identical rectangular elements on the z=0 plane. Each element is
        split into small rectangles (if required). As the sub-elements are
        small enough, the three-dimensional radiation patterns are derived
        by using Fraunhofer (far-field) equations.
    2) The paper that describes the first 2-D version of PFIELD is:
        SHAHRIARI S, GARCIA D. Meshfree simulations of ultrasound vector
        flow imaging using smoothed particle hydrodynamics. Phys Med Biol,
        2018;63:205011. <a
        href="matlab:web('https://www.biomecardio.com/publis/physmedbio18.pdf')">PDF here</a>
    3) The papers that describe the theory and validation of the 2-D + 3-D
        versions of PFIELD and SIMUS are:
        i)  GARCIA D. SIMUS: an open-source simulator for medical ultrasound
            imaging. Part I: theory & examples. Comput Methods Programs
            Biomed, 2022;218:106726. <a
            href="matlab:web('https://www.biomecardio.com/publis/cmpb22.pdf')">PDF here</a>
        ii) CIGIER A, VARRAY F, GARCIA D. SIMUS: an open-source simulator
            for medical ultrasound imaging. Part II:comparison with four
            simulators. Comput Methods Programs Biomed, 2022;220:106774.
            <a href="matlab:web('https://www.biomecardio.com/publis/cmpb22a.pdf')">PDF here</a>
    4) Use the fonction <a href="matlab:cite")>CITE</a> to guide you in citations.
    5) There is yet no publication for PFIELD3 (it is planned for 2023-24).
    """

    if x is None or (isinstance(x, list) and len(x) == 0):
        x =  np.array([])
    if y is None or (isinstance(y, list) and len(y) == 0):
        y =  np.array([])
    if z is None or (isinstance(z, list) and len(z) == 0):
        z =  np.array([])
       
    if options is None:
        if isinstance(isQuick, utils.Options):
            options = isQuick
            isQuick = False
        else:
            options = utils.Options()

    if isQuick:
        options.dBThresh = -20
        options.ElementSplitting = 1
        options.FullFrequencyDirectivity = False
        options.FrequencyStep = 1.5
    
    assert x.shape == y.shape and y.shape == z.shape, 'X, Y, and Z must be of same size.'

    #Check the transmit delays
    assert utils.isnumeric(delaysTX) and all(delaysTX[~np.isnan(delaysTX)]>=0),'DELAYS must be a nonnegative array.'

    NumberOfElements = delaysTX.shape[1]
    # Note: param.Nelements can be required in other functions of the
    #       Matlab Ultrasound Toolbox
    if 'Nelements' in param:
        assert param.Nelements==NumberOfElements, 'DELAYS must be of length PARAM.Nelements.'
    param.Nelements = NumberOfElements

    #delaysTX  should be a row vector
    if len(delaysTX.shape) == 1:
        delaysTX = delaysTX.reshape((1, -1), order='F')
    delaysTX = delaysTX.astype(np.float32)
    
    # Check if PFIELD3 is called by SIMUS3
    isSIMUS3 = False
    if 'CallFun' in options:
        isSIMUS3 = options.CallFun == 'simus3'
    
    #%---------------------------%
    #% Check the PARAM structure %
    #%---------------------------%

    param = param.ignoreCaseInFieldNames()

    #-- 1) Center frequency (in Hz)
    assert 'fc' in param, 'A center frequency value (PARAM.fc) is required.'
    fc = param.fc # central frequency (Hz)

    #-- 2) Coordinates of the transducer elements (xe,ye)
    # note: ze = 0 in this PFIELD3 version.
    assert 'elements' in param, 'PARAM.elements must contain the x- and y-locations of the transducer elements.'
    assert len(param.elements.shape) == 2 and param.elements.shape[0] == 2, 'PARAM.elements must have two rows that contain the x (1st row) and y (2nd row) coordinates of the transducer elements.'
    xe = param.elements[0, :]
    ye = param.elements[1, :]
    assert len(xe) == NumberOfElements, 'The number of elements must match the number of transmit delays.'
    
    #-- 3) Element width (in m)
    assert 'width' in param, 'An element width (PARAM.width) is required.'
    ElementWidth = param.width
    assert utils.isnumeric(ElementWidth) and np.isscalar(ElementWidth) and ElementWidth>0, 'The element width must be positive.'

    #-- 4) Element height (in m)
    assert 'height' in param, 'An element height (PARAM.height) is required with PFIELD3 and SIMUS3.'
    ElementHeight = param.height
    assert utils.isnumeric(ElementHeight) and np.isscalar(ElementHeight) and ElementHeight>0,'The element height must be positive.'

    #-- 5) Fractional bandwidth at -6dB (in %)
    if 'bandwidth' not in param:
        param.bandwidth = 75
    assert param.bandwidth>0 and param.bandwidth<200, 'The fractional bandwidth at -6 dB (PARAM.bandwidth, in %) must be in ]0,200[' #DR : is this a typo ]0,200[ or [0,200] ?

    #-- 6) Baffle
    #   An obliquity factor will be used if the baffle is not rigid
    #   (default = SOFT baffle)
    if  'baffle' not in param:
        param.baffle = 'soft' #  default

    if param.baffle == 'rigid':
        NonRigidBaffle = False
    elif param.baffle == 'soft':
        NonRigidBaffle = True
    elif np.isscalar(param.baffle):
        assert param.baffle>0, 'The "baffle" field scalar must be positive'
        NonRigidBaffle = True
    else:
        raise ValueError('The "baffle" field must be "rigid","soft" or a positive scalar')

    #-- 7) Longitudinal velocity (in m/s)
    if  'c' not in param:
        param.c = 1540 # default value

    c = param.c  # speed of sound (m/s)

    #-- 8) Attenuation coefficient (in dB/cm/MHz)
    if  'attenuation' not in param:  #no attenuation, alpha_dB = 0
        param.attenuation = 0
        alpha_dB = 0
    else:
        alpha_dB = param.attenuation
        assert np.isscalar(alpha_dB) and utils.isnumeric(alpha_dB) and alpha_dB>=0, 'PARAM.attenuation must be a nonnegative scalar'

    #-- 9) Transmit apodization (no unit)
    if  'TXapodization' not in param:
        param.TXapodization = np.ones((1,NumberOfElements), dtype = np.float32)
    else:
        if isinstance(param.TXapodization, np.ndarray) and len(param.TXapodization.shape) == 1:
            param.TXapodization = param.TXapodization.reshape((1, -1), order='F')
        assert (len(param.TXapodization.shape) == 2 and param.TXapodization.shape[0] == 1) and utils.isnumeric(param.TXapodization), 'PARAM.TXapodization must be a vector'
        assert param.TXapodization.shape[1]==NumberOfElements, 'PARAM.TXapodization must be of length = (number of elements)'

    # apodization is 0 where TX delays are NaN:
    idx = np.isnan(delaysTX)
    param.TXapodization[0, np.any(idx, axis = 0)]= 0
    delaysTX[idx] = 0

    #-- 10) TX pulse: Number of wavelengths
    if 'TXnow' not in param:
        param.TXnow = 1

    NoW = param.TXnow
    assert np.isscalar(NoW) and utils.isnumeric(NoW) and NoW>0, 'PARAM.TXnow must be a positive scalar.'

    #-- 11) TX pulse: Frequency sweep for a linear chirp
    if 'TXfreqsweep' not in param or np.isinf(NoW):
        param.TXfreqsweep = None

    FreqSweep = param.TXfreqsweep
    assert FreqSweep is None or (np.isscalar(FreqSweep) and utils.isnumeric(FreqSweep) and FreqSweep>0), 'PARAM.TXfreqsweep must be empty (windowed sine) or a positive scalar (linear chirp).'

    #%----------------------------------%
    #% END of Check the PARAM structure %
    #%----------------------------------%
    
    
    
    #%-----------------------------%
    #% Check the OPTIONS structure %
    #%-----------------------------%

    options = options.ignoreCaseInFieldNames()

    #-- 1) dB threshold
    #     (in dB: faster computation if lower value, but less accurate)
    if 'dBThresh' not in options:
        options.dBThresh = -60 # default is -60dB in PFIELD3

    assert np.isscalar(options.dBThresh) and utils.isnumeric(options.dBThresh) and options.dBThresh<=0,'OPTIONS.dBThresh must be a nonpositive scalar.'

    #-- 2) Frequency-dependent directivity?
    if utils.isfield(options,'FullFrequencyDirectivity'):
        isFFD = options.FullFrequencyDirectivity
    else:
        isFFD = False # default
        # By default, the directivity of the elements depends on the center
        # frequency only. This makes the algorithm faster. 

    assert np.isscalar(isFFD) and isinstance(isFFD, bool) ,'OPTIONS.FullFrequencyDirectivity must be a logical scalar (true or false).'

    #-- 3) Element splitting
    #
    # --- A short note about the algorithm:
    # Far-field equations are used in PFIELD3. Each transducer element of the
    # array is split into M-by-N small rectangles, so that these MN rectangles
    # have size smaller than one wavelength by one wavelength. The far-field
    # condition is acceptable for these small rectangles.
    #---
    if utils.isfield(options,'ElementSplitting') and not options.ElementSplitting is None:
        assert len(options.ElementSplitting) == 2, 'OPTIONS.ElementSplitting must be a two-element vector.'
        M = int(options.ElementSplitting[0])
        N = int(options.ElementSplitting[1])
        assert np.isscalar(M) and M==np.round(M) and M>0 and np.isscalar(N) and N==np.round(N) and N>0, 'OPTIONS.ElementSplitting must contain two positive integers.'
    else:
        LambdaMin = c/(fc*(1+param.bandwidth/200))
        M = int(np.ceil(ElementWidth/LambdaMin))
        N = int(np.ceil(ElementHeight/LambdaMin))

    #-- 4) Wait bar NOTE GB: this does not do nothing yet
    if not utils.isfield(options,'WaitBar'):
        options.WaitBar = True

    assert np.isscalar(options.WaitBar) and utils.islogical(options.WaitBar), 'OPTIONS.WaitBar must be a logical scalar (true or false).'

    #-- Advanced (masked) options: Frequency step (scaling factor)
    # The frequency step is determined automatically. It is tuned to avoid
    # significant interferences due to unadapted discretization. The frequency
    # step can also be adjusted by using a scaling factor. For a fast check,
    # you may use a scaling factor>1. For a smoother result, you may use a
    # scaling factor<1.
    if not utils.isfield(options,'FrequencyStep'):
        options.FrequencyStep = 1

    assert np.isscalar(options.FrequencyStep) and utils.isnumeric(options.FrequencyStep) and options.FrequencyStep>0, 'OPTIONS.FrequencyStep must be a positive scalar.'

    #%------------------------------------%
    #% END of Check the OPTIONS structure %
    #%------------------------------------%



    #-----
    # SIMUS3 first  runs PFIELD3 with empty X,Y,Z to detect syntax errors.
    if isSIMUS3 and len(x) == 0:
        return [], [], []
    #-----


    #%------------------------------------%
    #% POINT LOCATIONS, DISTANCES & GRIDS %
    #%------------------------------------%
    if len(x.shape) == 1:
        siz0 = (x.shape[0], 1)
    else:
        siz0 = x.shape
    nx = np.prod(x.shape)
    
    #-- Coordinates of the points where pressure is needed
    x = x.reshape((-1,1), order='F')
    y = y.reshape((-1,1), order='F')
    z = z.reshape((-1,1), order='F')

    # cast x, y, and z to single class
    x = x.astype(np.float32)
    y = y.astype(np.float32)
    z = z.astype(np.float32)

    #-- Centroids of the sub-elements
    #-- note: Each elements is split into M-by-N sub-elements.
    # X-position (xi) and Y-position (yi) of the centroids of the sub-elements
    # (relative to the centers of the transducer elements).
    # The values in xi are in the range ]-ElementWidth/2 ElementWidth/2[.
    # The values in yi are in the range ]-ElementHeight/2 ElementHeight/2[.
    # (if M = 1 and N = 1, then xi = yi = 0).
    SegWidth = ElementWidth/M
    xi = -ElementWidth/2 + SegWidth/2 + np.arange(M)*SegWidth
    SegHeight = ElementHeight/N
    yi = -ElementHeight/2 + SegHeight/2 + np.arange(N)*SegHeight
    xi,yi = np.meshgrid(xi,yi)
    xi = xi.reshape((1, 1,M*N), order='F')
    yi = yi.reshape((1, 1,M*N), order='F')

    #-- Out-of-field points
    # Null pressure will be assigned to out-of-field points.
    isOUT = z<0

    #-- Variables that we need:
    #
    # Note: We work in an ISO spherical system for each sub-element
    #       r = distance between the segment centroid and the point of interest
    #       sinT = sine theta: theta is the polar angle.
    #       cosT = cosine theta.
    #       sinP = sine phi: phi is the azimuthal angle.
    #       cosP = cosine phi.
    #       They are of size [numel(x) NumberOfElements M*N].
    #
    dxi = x.reshape((-1,1,1), order='F')-xi-xe.reshape((1, -1, 1), order='F')
    dyi = y.reshape((-1,1,1), order='F')-yi-ye.reshape((1, -1, 1), order='F')
    d2 = dxi**2+dyi**2
    r = np.sqrt(d2+z.reshape((-1,1,1), order='F')**2).astype(np.float32)

    eps_sp = np.finfo(np.float32).eps
    cosT = (np.expand_dims(z,axis=1)+eps_sp)/(r+eps_sp) # DR : expand dimensions to match the shape of r
    sinT = (np.sqrt(d2)+eps_sp)/(r+eps_sp)
    cosP = (dxi+eps_sp)/(np.sqrt(d2)+eps_sp)
    sinP = (dyi+eps_sp)/(np.sqrt(d2)+eps_sp)

    #---
    # The term 1/r is present in the equations (problems if r is very small!):
    # small r values are replaced by by lambda/2
    smallD = (c/fc/2)
    r[r<smallD] = smallD

    dxi, dyi, d2 = None, None, None # Clear memory if needed

    #%-------------------------------------------%
    #% end of POINT LOCATIONS, DISTANCES & GRIDS %
    #%-------------------------------------------%



    #%-------------------%
    #% FREQUENCY SPECTRA %
    #%-------------------%

    #-- FREQUENCY SPECTRUM of the transmitted pulse
    pulseSpectrum = param.getPulseSpectrumFunction(FreqSweep)

    #-- FREQUENCY RESPONSE of the ensemble PZT + probe
    probeSpectrum = param.getProbeFunction()

    # Note: The spectrum of the pulse (pulseSpectrum) will be then multiplied
    # by the frequency-domain tapering window of the transducer (probeSpectrum)

    #-- FREQUENCY STEP
    if isSIMUS3: # PFIELD3 has been called by SIMUS3
        df = options.FrequencyStep
    else: # We are in PFIELD3 only (i.e. not called by SIMUS3)
        # The frequency step df is chosen to avoid interferences due to
        # inadequate discretization.
        # -- df = frequency step (must be sufficiently small):
        # One has exp[-i(k r + w delay)] = exp[-2i pi(f r/c + f delay)] in the Eq.
        # One wants: the phase increment 2pi(df r/c + df delay) be < 2pi.
        # Therefore: df < 1/(r/c + delay).
        df = 1/(np.max(r/c) + np.max(delaysTX))
        df = options.FrequencyStep*df
        # note: df is here an upper bound; it will be recalculated below
        param.df = df

    #-- FREQUENCY SAMPLES
    Nf = int(2*np.ceil(param.fc/df)+1) # number of frequency samples
    f = np.linspace(0,2*param.fc,Nf) # frequency samples
    df = f[1]  # update the frequency step
    #-- we keep the significant components only by using options.dBThresh
    S = np.abs(pulseSpectrum(2*np.pi*f)*probeSpectrum(2*np.pi*f))

    GdB = 20*np.log10(1e-200 + S/np.max(S)) # gain in dB
    id = np.where(GdB>options.dBThresh)
    IDX = np.zeros(f.shape) != 0.
    IDX[id[0][0]:id[0][-1]+1] = True

    f = f[IDX]
    nSampling = len(f)

    #-- Frequency correction (added on April 24, 2023, removed on Nov 8, 2023) on MUST
    #   Note: The frequencies are shifted such that the center frequency for a
    #         a pulse-echo is exactly PARAM.fc.
    # pulse-echo spectrum
    # F = pulseSpectrum(2*np.pi*f)*probeSpectrum(2*np.pi*f)**2
    # predicted center frequency
    # P = np.abs(F)**2 # power
    # Fc = np.trapz(f*P)/np.trapz(P)
    # corrected frequencies
    # f = f+Fc-fc

    #-- we need VECTORS
    pulseSPECT = pulseSpectrum(2*np.pi*f) # pulse spectrum
    probeSPECT = probeSpectrum(2*np.pi*f) # probe response

    #%--------------------------%
    #% end of FREQUENCY SPECTRA %
    #%--------------------------%

    #-- Initialization
    RP = 0 # RP = Radiation Pattern
    if isSIMUS3:
        #- For SIMUS3 only (we need the full spectrum of RX signals):
        SPECT = np.zeros((nSampling, NumberOfElements), dtype = np.complex64)
    else:
        SPECT = np.zeros((nSampling,nx),dtype=np.complex64)

    #-- Obliquity factor (baffle property)
    #   An obliquity factor is required if the baffle is not rigid.
    #   [Th = angle relative to the element normal axis]
    if NonRigidBaffle:
        if param.baffle == 'soft':
            ObliFac = cosT
        else: # param.baffle is a scalar
            ObliFac = cosT/(cosT+param.baffle)
    else: # 1 if rigid baffle
        ObliFac = np.ones(cosT.shape, np.float32)

    #-- Note on Attenuation
    # Reference: Diagnostic ultrasound imaging - inside out (T.L. Szabo)
    #            Chapter 4: Attenuation
    # Key reference: Acoustics for ultrasound imaging (Ben Cox, 2013)
    #                Chapter 5: Acoustic attenuation and absorption
    # We will use this attenuation-based wavenumber:
    #   kwa = alpha_dB/8.69*f(k)/1e6*1e2; % P(z,f) = P0 exp(-alpha*f*z/8.69)
    #   note: 20/log(10) ~ 8.69

    #-- EXPONENTIAL arrays of size [numel(x) NumberOfElements M]
    kw = 2*np.pi*f[0]/c # wavenumber
    kwa = alpha_dB/8.69*f[0]/1e6*1e2 # attenuation-based wavenumber
    EXP = np.exp(-kwa*r + 1j*np.mod(kw*r,2*np.pi)).astype(np.complex64) # faster than exp(-kwa*r+1j*kw*r)
    #-- Exponential array for the increment wavenumber dk
    dkw = 2*np.pi*df/c
    dkwa = alpha_dB/8.69*df/1e6*1e2
    EXPdf = np.exp((-dkwa + 1j*dkw)*r).astype(np.complex64)

    #-- We replace EXP by EXP*ObliFac/r
    EXP = EXP*ObliFac/r

    if options.RC is not None and len(options.RC): #DR : shouldn't this be checked at the "Check the OPTIONS structure"
        options.RC = options.RC.astype(np.float32)

    #-- TX apodization
    APOD = param.TXapodization.flatten(order='F')

    #-- Simplified directivity (if not dependent on frequency)
    # In the "simplified directivity" version, the directivities of the
    # sub-elements depend on the center frequency ONLY. It is thus not needed
    # to calculate the directivity arrays (DIRx and DIRy) in the following
    # for-loop. These directivities DIRx and DIRy are included in the variable
    # EXP to reduce storage.
    if not isFFD:
        kc = 2*np.pi*fc/c # center wavenumber
        DIRx = mysinc(kc*SegWidth/2*cosP*sinT) # x-directivity of each segment
        DIRy = mysinc(kc*SegHeight/2*sinP*sinT) # y-directivity of each segment
        EXP = EXP*DIRx*DIRy



    #%-----------------------------%
    #% SUMMATION OVER THE SPECTRUM %
    #%-----------------------------%
    EXP = EXP.astype(np.complex64)

    # TODO GB: process several frequencies at the same time might remove some overhead of numpy calls

    for k in range(nSampling):

        kw = 2*np.pi*f[k]/c # wavenumber

        #-- Exponential array of size [numel(x) NumberOfElements MxN]
        # For all k, we need: EXP = exp((-kwa+1i*kw)*r)
        #                         with kw = 2*pi*f(k)/c;
        #                     and with kwa = alpha_dB/8.7*f(k)/1e6*1e2;
        # Since f(k) = f(1)+(k-1)df, we use the following recursive product:

        if k>0:
            EXP = EXP*EXPdf

        #-- Directivity (if frequency-dependent)
        if isFFD: # isFFD = true -> frequency-dependent directivity
            DIRx = mysinc(kw*SegWidth/2*cosP*sinT) # x-directivity
            DIRy = mysinc(kw*SegHeight/2*sinP*sinT) # y-directivity
            DIR = DIRx*DIRy

        #-- Radiation patterns of the single elements
        # They are the combination of the far-field patterns of the M small
        # segments that make up the single elements
        #-- DR : combine M*N small segments?
        if isFFD: # isFFD = true -> frequency-dependent directivity
            #TODO: CHECK THIS IS CORRECT
            RPmono =  average_over_last_axis(DIR*EXP) # summation over the M*N small segments
        else: # isFFD = false: the directivity depends on center frequency only
            # note: the directivity (DIR) has already been included in EXP
            if M*N>1:
                RPmono = average_over_last_axis(EXP) # summation over the M*N small segments
            else:
                RPmono = EXP

        if len(RPmono.shape) == 3 and RPmono.shape[2] == 1:
            RPmono = RPmono.reshape((RPmono.shape[0],RPmono.shape[1]), order='F')


        #-- Transmit delays + Transmit apodization
        # use of SUM: summation over the number of delay series (e.g. MLT)
        #GB WARNING, HERE delays are a row vector instead of a column as in matlab

        DELAPOD = np.sum(np.exp(1j*kw*c*delaysTX), 0) *APOD

        #-- Summing the radiation patterns generating by all the elements
        RPk = RPmono@DELAPOD.reshape((-1, 1), order='F')

        #- include spectrum responses:
        RPk = pulseSPECT[k]*RPk* probeSPECT[k]

        RPk[isOUT] = 0 #<- if not jax

        #-- Output
        if isSIMUS3: # Receive: for SIMUS3 only (spectra of the RF signals)
            SPECT[k,:] = probeSPECT[k]  # the array bandwidth is considered

            SPECT[k,:] *= ((RPk.flatten(order='F')*options.RC.flatten(order='F')).reshape((1, -1), order='F') @ RPmono).flatten(order='F')  # pressure received by the elements)
            # SPECT[k, :] *= np.dot(RPk.flatten()*options.RC.flatten(), RPmono ) # Trying to see if it is faster, no evidence whatsoever
            # *f(k)^2/fc^2; Rayleigh scattering (OPTIONAL)

            if np.any(param.RXdelay != 0): # reception delays, if any
                SPECT[k,:] = SPECT[k,:] *np.exp(1j*kw*c*param.RXdelay)
        else:  # using PFIELD3 alone
            RP = RP + abs(RPk)**2 # acoustic intensity

            SPECT[k,:] = RPk.flatten(order='F')


    #%------------------------------------%
    #% end of SUMMATION OVER THE SPECTRUM %
    #%------------------------------------%

    # Correcting factor (including integration step, df)
    if np.isinf(NoW):
        CorFac = 1
    else:
        CorFac = df

    # SPECT = SPECT*CorFac # DR : MUST implementation has this line commented
    RP = RP*CorFac

    # RMS acoustic pressure (if we are in PFIELD3 only)
    if not isSIMUS3:
        RP =np.sqrt(RP).reshape(siz0, order='F')
        SPECT = np.moveaxis(SPECT, 0, -1)
        SPECT = SPECT.reshape([siz0[0], siz0[1], siz0[2], nSampling], order='F')

    return RP, SPECT, IDX
