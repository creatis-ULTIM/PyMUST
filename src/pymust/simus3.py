from . import utils, pfield3, getpulse
import logging, copy, multiprocessing, functools
import numpy as np 

# pfield wrapper so it is compatible with multiprocessing. Needs to be defined in a global scope
def pfieldParallel3(x, y, z, RC, delaysTX, param, options):
    options = options.copy()
    options.ParPool = False # No parallel within the parallel
    options.RC = RC
    _, RFsp, idx =  pfield3(x, y, z, delaysTX, param, options)
    return RFsp, idx


def simus3(*varargin):
    """
    SIMUS3   Simulation of ultrasound RF signals for a a planar 2-D array
    RF = SIMUS3(X,Y,Z,RC,DELAYS,PARAM) simulates ultrasound RF radio-
    frequency signals generated by an ultrasound planar 2-D array
    insonifying a medium of scatterers.
    The scatterers are characterized by their coordinates (X,Y,Z) and
    reflection coefficients RC.

    Use SIMUS for uniform linear or convex arrays. 

    X, Y, Z and RC must be of same size. The elements of the 2-D array are
    excited at different time delays, given by the vector DELAYS. The
    transmission and reception characteristics must be given in the
    structure PARAM (see below for details).

    >--- Try it: enter "simus3" in the command window for an example ---< 

    The RF output matrix contains Number_of_Elements columns. Each column
    therefore represents an RF signal. The number of rows depends on the
    depth and the sampling frequency PARAM.fs (see below). By default, the
    sampling frequency is four times the center frequency.

    Units: X,Y,Z must be in m; DELAYS must be in s; RC has no unit.

    DELAYS can be a matrix. This syntax can be used to simulate MPT
    (multi-plane transmit) sequences. In this case, each ROW represents a
    delay series. For example, to create a 4-MPT sequence with a
    1024-element matrix array, the DELAYS matrix must have 4 rows and 1024
    columns (size = [4 1024]).
    Note: Use TXDELAY3 to create standard delays (focus point, focus line,
            plane waves, diverging waves) with a matrix array.

    SIMUS3 uses PFIELD3 during transmission and reception. The parameters
    that must be included in the structure PARAM are similar as those in
    PFIELD3. Additional parameters are also required (see below).

    ---
    NOTE #1: X-, Y-, and Z-axes
    Conventional axes are used:
    The X-axis is PARALLEL to the transducer and points from the first
    (leftmost) element to the last (rightmost) element (X = 0 at the CENTER
    of the transducer). The Z-axis is PERPENDICULAR to the transducer and
    points downward (Z = 0 at the level of the transducer, Z increases as
    depth increases). The Y-axis is such that the coordinates are
    right-handed.
    ---
    NOTE #2: Simplified method: Directivity
    By default, the calculation is made faster by assuming that the
    directivity of the elements is dependent only on the central frequency.
    This simplification very little affects the pressure field in most
    situations (except near the array). To turn off this option, use
    OPTIONS.FullFrequencyDirectivity = true.
    (see ADVANCED OPTIONS below).
    ---

    PARAM is a structure that contains the following fields:
    -------------------------------------------------------
        *** TRANSDUCER PROPERTIES ***
    1)  PARAM.fc: central frequency (in Hz, REQUIRED)
    2)  PARAM.elements: x- and y-coordinates of the element centers
            (in m, REQUIRED). It MUST be a two-row matrix, with the 1st
            and 2nd rows containing the x and y coordinates, respectively. 
    3)  PARAM.width: element width, in the x-direction (in m, REQUIRED)
    4)  PARAM.height: element height, in the y-direction (in m, REQUIRED)
    5)  PARAM.bandwidth: pulse-echo 6dB fractional bandwidth (in %)
            The default is 75%.
    6)  PARAM.baffle: property of the baffle:
            'soft' (default), 'rigid', or a scalar > 0.
            See "Note on BAFFLE properties" below for details

        *** MEDIUM PARAMETERS ***
    7)  PARAM.c: longitudinal velocity (in m/s, default = 1540 m/s)
    8)  PARAM.attenuation: attenuation coefficient (dB/cm/MHz, default: 0)
            Notes: A linear frequency-dependence is assumed.
                    A typical value for soft tissues is ~0.5 dB/cm/MHz.

        *** TRANSMIT PARAMETERS ***
    9)  PARAM.TXapodization: transmit apodization (default: no apodization)
    10) PARAM.TXnow: number of wavelengths of the TX pulse (default: 1)
    11) PARAM.TXfreqsweep: frequency sweep for a linear chirp (default: [])
                            To be used to simulate a linear TX down-chirp.

        *** RECEIVE PARAMETERS *** (not in PFIELD3)
    14) PARAM.fs: sampling frequency (in Hz, default = 4*param.fc)
    15) PARAM.RXdelay: reception law delays (in s, default = 0)

    Other syntaxes:
    --------------
    i}  [RF,PARAM] = SIMUS3(...) updates the fields of the PARAM structure.
    ii} [...] = SIMUS3 without any input argument provides an example
        designed to produce RF signals from a focused ultrasound beam
        using a 3 MHz matrix array transducer.

    PARALLEL COMPUTING:
    ------------------
    SIMUS3 calls the function PFIELD3. If you have the Parallel Computing
    Toolbox, SIMUS3 can execute several PFIELD3 in parallel. If this option
    is activated, a parallel pool is created on the default cluster. All
    workers in the pool are used. The X,Y,Z are splitted into NW chunks, NW
    being the number of workers. To execute parallel computing, use:
        [...] = SIMUS3(...,OPTIONS),
    with OPTIONS.ParPool = true (default = false).


    OTHER OPTIONS:
    -------------
        %-- FREQUENCY STEP & FREQUENCY SAMPLES --%
    1a) Only frequency components of the transmitted signal in the range
        [0,2fc] with significant amplitude are considered. The default
        relative amplitude is -100 dB. You can change this value by using
        the following:
            [...] = SIMUS3(...,OPTIONS),
        where OPTIONS.dBThresh is the threshold in dB (default = -100).
    1b) The frequency step is determined automatically to avoid aliasing in
        the time domain. This step can be adjusted with a scaling factor
        OPTIONS.FrequencyStep (default = 1). It is not recommended to
        modify this scaling factor in SIMUS3.
    ---
        %-- FULL-FREQUENCY DIRECTIVITY --%   
    2)  By default, the directivity of the elements depends only on the
        center frequency. This makes the calculation faster. To make the
        directivities fully frequency-dependent, use: 
            [...] = SIMUS3(...,OPTIONS),
        with OPTIONS.FullFrequencyDirectivity = true (default = false).
    ---
        %-- ELEMENT SPLITTING --%   
    3)  Each transducer element of the array is split into small rectangles.
        The width and height and of these small rectangles must be small
        enough to ensure that the far-field model is accurate. By default,
        the elements are split into M-by-N rectangles, with M and N being
        defined by:
            M = ceil(element_width/smallest_wavelength);
            N = ceil(element_height/smallest_wavelength);
        To modify the number MN of subelements by splitting, you may adjust
        OPTIONS.ElementSplitting, which must contain two elements. For
        example, OPTIONS.ElementSplitting = [1 3].
    ---
        %-- WAIT BAR --%   
    4)  If OPTIONS.WaitBar is true, a wait bar appears (only if the number
        of frequency samples >10). Default is true.
    ---


    Notes regarding the model & REFERENCES:
    --------------------------------------
    1) SIMUS3 calls the function PFIELD3. It works for planar 2-D arrays.
        It considers arrays that have identical rectangular elements on the
        z=0 plane. Each element is split into small rectangles (if
        required). As the sub-elements are small enough, the
        three-dimensional radiation patterns are derived by using Fraunhofer
        (far-field) equations.
    2) The paper that describes the first 2-D version of SIMUS is:
        SHAHRIARI S, GARCIA D. Meshfree simulations of ultrasound vector
        flow imaging using smoothed particle hydrodynamics. Phys Med Biol,
        2018;63:205011. <a
        href="matlab:web('https://www.biomecardio.com/publis/physmedbio18.pdf')">PDF here</a>
    3) The papers that describe the theory and validation of the 2-D + 3-D
        versions of PFIELD and SIMUS are:
        i)  GARCIA D. SIMUS: an open-source simulator for medical ultrasound
            imaging. Part I: theory & examples. Comput Methods Programs
            Biomed, 2022;218:106726. <a
            href="matlab:web('https://www.biomecardio.com/publis/cmpb22.pdf')">PDF here</a>
        ii) CIGIER A, VARRAY F, GARCIA D. SIMUS: an open-source simulator
            for medical ultrasound imaging. Part II:comparison with four
            simulators. Comput Methods Programs Biomed, 2022;220:106774.
            <a href="matlab:web('https://www.biomecardio.com/publis/cmpb22a.pdf')">PDF here</a>
    4) Use the fonction <a href="matlab:cite")>CITE</a> to guide you in citations.
    5) There is yet no publication for SIMUS3 (it is planned for 2023-24).
    
    This function is part of <a
    href="matlab:web('https://www.biomecardio.com/MUST')">MUST</a> (Matlab UltraSound Toolbox).
    MUST (c) 2020 Damien Garcia, LGPL-3.0-or-later

    See also SIMUS, PFIELD3, TXDELAY3, GETPARAM, GETPULSE, CITE.

    -- Damien Garcia -- 2022/10, last update 2022/12/01
    website: <a
    href="matlab:web('https://www.biomecardio.com')">www.BiomeCardio.com</a>
    """

    returnTime = False #NoteGB: Set to True if you want to return the time, but quite a mess right now with the matlab style arguments

    nargin = len(varargin)
    if nargin<= 3 or nargin > 7: # DR : should nargin<= 5 ? Only valid 6 or 7
        raise ValueError("Wrong number of input arguments.")
    #-- Input variables: X,Y,Z,DELAYS,PARAM,OPTIONS
    x = varargin[0]

    if nargin == 6: # simus3(X,Y,Z,RC,DELAYS,PARAM)
        y = varargin[1]
        z = varargin[2]
        RC = varargin[3]
        delaysTX = varargin[4]
        param = varargin[5]
        options = utils.Options()
    else: # simus3(X,Y,Z,RC,DELAYS,PARAM,OPTIONS)
        y = varargin[1]
        z = varargin[2]
        RC = varargin[3]
        delaysTX = varargin[4]
        param = varargin[5]
        options = copy.deepcopy(varargin[6])
    assert isinstance(param, utils.Param),'PARAM must be a structure.'

    #-- X,Y,Z size
    assert x.shape == z.shape and x.shape == RC.shape and y.shape == x.shape,  'X, Y, Z, and RC must be of same size.'

    if len(x.shape) == 0:
        return np.array([]), np.array([])


    #%------------------------%
    #% CHECK THE INPUT SYNTAX %
    #%------------------------%


    param = param.ignoreCaseInFieldNames()
    options = options.ignoreCaseInFieldNames()
    options.CallFun = 'simus3'

    # GB TODO: wait bar + parallelisation
    #%-- Wait bar
    #if ~isfield(options,'WaitBar')
    #    options.WaitBar = true;
    #end
    #assert(isscalar(options.WaitBar) && islogical(options.WaitBar),...
    #    'OPTIONS.WaitBar must be a logical scalar (true or false).')

    #%-- Parallel pool
    #if ~isfield(options,'ParPool')
    #    options.ParPool = False
    #end

    #%-- Check if syntax errors may appear when using PFIELD3
    #try:
    #    opt = options
    #    opt.ParPool = false;
    #    opt.WaitBar = false;
    #    [~,param] = pfield([],,[],[],delaysTX,param,opt);
    #catch ME
    #    throw(ME)
    #end

    #-- Sampling frequency (in Hz)
    if not utils.isfield(param,'fs'):
        param.fs = 4*param.fc # default

    assert param.fs>=4*param.fc,'PARAM.fs must be >= 4*PARAM.fc.'

    NumberOfElements = param.elements.shape[1] # number of array elements

    #-- Receive delays (in s)
    if not utils.isfield(param,'RXdelay'):
        param.RXdelay = np.zeros((1,NumberOfElements), dtype = np.float32)
    else:
        assert  isinstance(param.RXdelay, np.ndarray) and utils.isnumeric(param.RXdelay), 'PARAM.RXdelay must be a vector'
        assert param.RXdelay.shape[1] ==NumberOfElements, 'PARAM.RXdelay must be of length = (number of elements)'
        param.RXdelay = param.RXdelay.reshape((1,NumberOfElements), order='F')

    #-- dB threshold (in dB: faster computation if lower value)
    if not utils.isfield(options,'dBThresh'):
        options.dBThresh = -100; # default is -100dB in SIMUS3

    assert np.isscalar(options.dBThresh) and utils.isnumeric(options.dBThresh) and options.dBThresh<0,'OPTIONS.dBThresh must be a negative scalar.'

    #-- Frequency step (scaling factor)
    # The frequency step is determined automatically. It is tuned to avoid
    # aliasing in the temporal domain. The frequency step can be adjusted by
    # using a scaling factor. For a smoother result, you may use a scaling
    # factor<1.
    if not utils.isfield(options,'FrequencyStep'):
        options.FrequencyStep = 1

    assert np.isscalar(options.FrequencyStep) and utils.isnumeric(options.FrequencyStep) and  options.FrequencyStep>0, 'OPTIONS.FrequencyStep must be a positive scalar.'

    if options.FrequencyStep>1:
       logging.warning('MUST:FrequencyStep', 'OPTIONS.FrequencyStep is >1: aliasing may be present!')

    if not utils.isfield(param, 'c'):
         param.c = 1540 # default sound speed in soft tissue


    #%-------------------------------%
    #% end of CHECK THE INPUT SYNTAX %
    #%-------------------------------%

    #GB NOTE: same as in pfield, put in param ?
    #-- Centers of the tranducer elements (x- and z-coordinates)
    xe = param.elements[0,:]
    ye = param.elements[1,:]

    #-- Maximum distance
    d2 = (x.reshape((-1,1),order='F')-xe)**2+(y.reshape((-1,1),order='F')-ye)**2 + z.reshape((-1,1),order='F')**2
    maxD = np.sqrt(np.max(d2)) # maximum element-scatterer distance
    _, tp = getpulse.getpulse(param, 2)
    maxD = maxD + tp[-1] * param.c # add pulse length

    #-- FREQUENCY SAMPLES
    df = 1/2/(2*maxD/param.c + np.max(delaysTX.flatten(order='F') + param.RXdelay.flatten(order='F'))) # to avoid aliasing in the time domain
    df = df*options.FrequencyStep
    Nf = 2*int(np.ceil(param.fc/df))+1 # number of frequency samples
    #-- Run PFIELD3 to calculate the RF spectra
    RFspectrum = np.zeros((Nf,NumberOfElements), dtype = np.complex64) # will contain the RF spectra
    options.FrequencyStep = df

    #-- run PFIELD3 in a parallel pool (NW workers)
    if options.get('ParPool', False):

        with options.getParallelPool() as pool:
            idx = options.getParallelSplitIndices(x.shape[1])

            RS = pool.starmap(functools.partial(pfieldParallel3, delaysTX = delaysTX, param = param, options = options),
                            [ ( x[:,i:j],
                                y[:,i:j],
                                z[:,i:j],
                                RC[:,i:j]) for i,j in idx])


            for (RFsp, idx_spectrum) in RS: 
                RFspectrum[idx_spectrum, :] += RFsp


    else:
        #- no parallel pool
        options.RC =  RC
        _, RFsp,idx = pfield3(x,y,z,delaysTX,param,options)
        RFspectrum[idx,:]  = RFsp

    #-- RF signals (in the time domain)
    nf = int(np.ceil(param.fs/2/param.fc*(Nf-1)))
    RF = np.fft.irfft(np.conj(RFspectrum),nf, axis = 0)
    RF = RF[:(nf + 1)//2] #*param.fs/4/param.fc

    #-- Zeroing the very small values
    RelThresh = 1e-5# -100 dB
    tmp2= lambda RelRF: 0.5*(1+np.tanh((RelRF-RelThresh)/(RelThresh/10)))
    tmp = lambda RelRF: np.round(tmp2(RelRF)/(RelThresh/10))*(RelThresh/10)
    RF = RF*tmp(np.abs(RF)/np.max(np.abs(RF))) # DR: MUST has + eps in the denominator
    if returnTime:
        return RF,RFspectrum, np.arange(RF.shape[0])/param.fs
    else:
        return RF,RFspectrum
